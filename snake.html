<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Snake: Cyber Grid</title>
    <style>
        :root {
            --bg-color: #050510;
            --grid-line: #1a1a2e;
            --primary-neon: #00ffcc;
            --secondary-neon: #ff00ff;
            --food-neon: #ffcc00;
            --text-color: #ffffff;
            --ui-bg: rgba(10, 10, 25, 0.85);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Background Grid Animation */
        .bg-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 200%;
            height: 200%;
            background-image: 
                linear-gradient(var(--grid-line) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-line) 1px, transparent 1px);
            background-size: 40px 40px;
            transform: perspective(500px) rotateX(60deg) translateY(-100px) translateZ(-200px);
            opacity: 0.4;
            animation: gridMove 20s linear infinite;
            z-index: -1;
            pointer-events: none;
        }

        @keyframes gridMove {
            0% { transform: perspective(500px) rotateX(60deg) translateY(0) translateZ(-200px); }
            100% { transform: perspective(500px) rotateX(60deg) translateY(40px) translateZ(-200px); }
        }

        /* UI Container */
        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 255, 204, 0.1);
            border: 2px solid var(--grid-line);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
        }

        canvas {
            display: block;
            border-radius: 6px;
            cursor: pointer;
        }

        /* HUD (Heads Up Display) */
        .hud {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            padding: 0 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 0 0 10px var(--primary-neon);
            z-index: 10;
        }

        .score-box span {
            color: var(--primary-neon);
        }

        /* Overlays (Start, Game Over, Pause) */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--ui-bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            transition: opacity 0.3s ease;
            border-radius: 8px;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, var(--primary-neon), var(--secondary-neon));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
            text-align: center;
        }

        p {
            margin-bottom: 30px;
            font-size: 1.1rem;
            color: #aaa;
            text-align: center;
            max-width: 80%;
            line-height: 1.5;
        }

        /* Neon Buttons */
        .btn {
            background: transparent;
            color: var(--primary-neon);
            font-family: inherit;
            font-size: 1.5rem;
            font-weight: bold;
            padding: 12px 40px;
            border: 2px solid var(--primary-neon);
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.2);
            text-transform: uppercase;
            outline: none;
        }

        .btn:hover {
            background: var(--primary-neon);
            color: var(--bg-color);
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.8);
            transform: scale(1.05);
        }

        .btn:active {
            transform: scale(0.95);
        }

        /* Shake Animation for Game Over */
        .shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* Controls Hint */
        .controls-hint {
            margin-top: 20px;
            font-size: 0.9rem;
            opacity: 0.7;
            display: flex;
            gap: 15px;
        }
        .key {
            border: 1px solid #555;
            padding: 2px 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
        }

        /* Responsive adjustments */
        @media (max-width: 600px) {
            h1 { font-size: 2rem; }
            .btn { font-size: 1.2rem; padding: 10px 30px; }
        }
    </style>
</head>
<body>

    <div class="bg-grid"></div>

    <div id="game-container">
        <!-- HUD -->
        <div class="hud">
            <div class="score-box">SCORE: <span id="scoreEl">0</span></div>
            <div class="score-box">BEST: <span id="highScoreEl">0</span></div>
        </div>

        <!-- Canvas -->
        <canvas id="gameCanvas" width="600" height="600"></canvas>

        <!-- Start Screen -->
        <div id="startScreen" class="overlay">
            <h1>NEON SNAKE</h1>
            <p>Use Arrow Keys or WASD to move.<br>Eat energy particles to grow.<br>Don't hit the walls.</p>
            <button class="btn" id="startBtn">Play Game</button>
            <div class="controls-hint">
                <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="gameOverScreen" class="overlay hidden">
            <h1>SYSTEM FAILURE</h1>
            <p>Final Score: <span id="finalScore" style="color:white; font-weight:bold;">0</span></p>
            <button class="btn" id="restartBtn">Reboot System</button>
        </div>

        <!-- Pause Screen -->
        <div id="pauseScreen" class="overlay hidden">
            <h1>PAUSED</h1>
            <button class="btn" id="resumeBtn">Resume</button>
        </div>
    </div>

    <script>
        /**
         * NEON SNAKE - CORE LOGIC
         * Includes: Game Loop, Particle System, Audio Synthesis, Input Handling
         */

        // --- Configuration ---
        const CANVAS_SIZE = 600;
        const GRID_SIZE = 20;
        const TILE_COUNT = CANVAS_SIZE / GRID_SIZE;
        const INITIAL_SPEED = 100; // ms per tick
        const SPEED_INCREMENT = 2; // ms faster per food
        const MIN_SPEED = 40;

        // --- Colors ---
        const COLOR_SNAKE_HEAD = '#00ffcc';
        const COLOR_SNAKE_BODY = '#00ccaa';
        const COLOR_FOOD = '#ffcc00';
        const COLOR_PARTICLE = ['#ff00ff', '#00ffff', '#ffffff'];

        // --- Audio Context (Web Audio API) ---
        let audioCtx;
        
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('game-container');
        const scoreEl = document.getElementById('scoreEl');
        const highScoreEl = document.getElementById('highScoreEl');
        const finalScoreEl = document.getElementById('finalScore');
        
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const pauseScreen = document.getElementById('pauseScreen');

        // --- Game State ---
        let snake = [];
        let velocity = { x: 0, y: 0 };
        let food = { x: 0, y: 0 };
        let particles = [];
        let score = 0;
        let highScore = localStorage.getItem('neonSnakeHighScore') || 0;
        let gameInterval;
        let isPaused = false;
        let isGameOver = false;
        let currentSpeed = INITIAL_SPEED;
        let lastRenderTime = 0;

        // Initialize UI
        highScoreEl.innerText = highScore;

        // --- Audio System (Synthesizer) ---
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playSound(type) {
            if (!audioCtx) return;

            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'eat') {
                // High pitched "coin" sound
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'die') {
                // Low pitched "crash" sound
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.4);
                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                osc.start(now);
                osc.stop(now + 0.4);
            } else if (type === 'move') {
                // Very subtle click
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(200, now);
                gainNode.gain.setValueAtTime(0.05, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
                osc.start(now);
                osc.stop(now + 0.03);
            }
        }

        // --- Particle System ---
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.alpha = 1;
                this.decay = Math.random() * 0.03 + 0.01;
                this.size = Math.random() * 4 + 2;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.alpha -= this.decay;
                this.size *= 0.95; // Shrink
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.restore();
            }
        }

        function spawnParticles(x, y, count = 10) {
            // Convert grid coordinates to pixel coordinates for particles
            const px = x * GRID_SIZE + GRID_SIZE / 2;
            const py = y * GRID_SIZE + GRID_SIZE / 2;
            
            for (let i = 0; i < count; i++) {
                const color = COLOR_PARTICLE[Math.floor(Math.random() * COLOR_PARTICLE.length)];
                particles.push(new Particle(px, py, color));
            }
        }

        // --- Game Logic ---

        function initGame() {
            initAudio();
            snake = [
                { x: 10, y: 10 },
                { x: 10, y: 11 },
                { x: 10, y: 12 }
            ];
            velocity = { x: 0, y: -1 }; // Start moving up
            score = 0;
            currentSpeed = INITIAL_SPEED;
            particles = [];
            isGameOver = false;
            isPaused = false;
            scoreEl.innerText = score;
            
            placeFood();
            
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            pauseScreen.classList.add('hidden');
            container.classList.remove('shake');
            
            // Start Loop
            lastRenderTime = 0;
            requestAnimationFrame(gameLoop);
        }

        function placeFood() {
            let validPosition = false;
            while (!validPosition) {
                food = {
                    x: Math.floor(Math.random() * TILE_COUNT),
                    y: Math.floor(Math.random() * TILE_COUNT)
                };
                // Ensure food doesn't spawn on snake
                validPosition = !snake.some(segment => segment.x === food.x && segment.y === food.y);
            }
        }

        function update() {
            // Calculate new head position
            const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };

            // Collision Detection: Walls
            if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) {
                handleGameOver();
                return;
            }

            // Collision Detection: Self
            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                handleGameOver();
                return;
            }

            // Move Snake
            snake.unshift(head); // Add new head

            // Check Food
            if (head.x === food.x && head.y === food.y) {
                // Eat food
                score += 10;
                scoreEl.innerText = score;
                playSound('eat');
                spawnParticles(head.x, head.y, 15);
                placeFood();
                
                // Increase difficulty
                if (currentSpeed > MIN_SPEED) {
                    currentSpeed -= SPEED_INCREMENT;
                }
            } else {
                // Remove tail if didn't eat
                snake.pop();
            }
        }

        function handleGameOver() {
            isGameOver = true;
            playSound('die');
            container.classList.add('shake');
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('neonSnakeHighScore', highScore);
                highScoreEl.innerText = highScore;
            }
            finalScoreEl.innerText = score;
            
            setTimeout(() => {
                gameOverScreen.classList.remove('hidden');
            }, 500);
        }

        // --- Rendering ---

        function draw() {
            // Clear Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Food (Pulsing Glow)
            const pulse = Math.sin(Date.now() / 100) * 5 + 10;
            ctx.save();
            ctx.shadowBlur = 20;
            ctx.shadowColor = COLOR_FOOD;
            ctx.fillStyle = COLOR_FOOD;
            ctx.beginPath();
            ctx.arc(
                food.x * GRID_SIZE + GRID_SIZE / 2, 
                food.y * GRID_SIZE + GRID_SIZE / 2, 
                (GRID_SIZE / 2) - 2, 
                0, Math.PI * 2
            );
            ctx.fill();
            ctx.restore();

            // Draw Snake
            snake.forEach((segment, index) => {
                const isHead = index === 0;
                ctx.fillStyle = isHead ? COLOR_SNAKE_HEAD : COLOR_SNAKE_BODY;
                
                // Add Glow
                if (isHead) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = COLOR_SNAKE_HEAD;
                } else {
                    ctx.shadowBlur = 0;
                }

                // Draw rounded rectangles for segments
                const x = segment.x * GRID_SIZE + 1;
                const y = segment.y * GRID_SIZE + 1;
                const size = GRID_SIZE - 2;
                
                ctx.fillRect(x, y, size, size);
                
                // Draw eyes on head
                if (isHead) {
                    ctx.fillStyle = '#000';
                    ctx.shadowBlur = 0;
                    // Determine eye position based on velocity
                    let eyeOffsetX = 0, eyeOffsetY = 0;
                    if (velocity.x === 1) eyeOffsetX = 4;
                    if (velocity.x === -1) eyeOffsetX = -4;
                    if (velocity.y === 1) eyeOffsetY = 4;
                    if (velocity.y === -1) eyeOffsetY = -4;

                    // Simplified eyes
                    ctx.fillRect(x + size/2 + eyeOffsetX - 2, y + size/2 + eyeOffsetY - 2, 4, 4);
                }
            });

            // Draw Particles
            particles.forEach((p, index) => {
                if (p.alpha <= 0) {
                    particles.splice(index, 1);
                } else {
                    p.update();
                    p.draw(ctx);
                }
            });
        }

        function gameLoop(currentTime) {
            if (isGameOver) return;
            if (isPaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            window.requestAnimationFrame(gameLoop);

            const secondsSinceLastRender = (currentTime - lastRenderTime) / 1000;
            if (secondsSinceLastRender < currentSpeed / 1000) return;

            lastRenderTime = currentTime;

            update();
            draw();
        }

        // --- Input Handling ---

        window.addEventListener('keydown', e => {
            // Prevent scrolling with arrows
            if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
                e.preventDefault();
            }

            if (isGameOver) return;

            // Pause Toggle
            if (e.code === 'Space' || e.key === 'Escape') {
                togglePause();
                return;
            }

            if (isPaused) return;

            // Movement Logic (prevent 180 degree turns)
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    if (velocity.y === 0) { velocity = { x: 0, y: -1 }; playSound('move'); }
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    if (velocity.y === 0) { velocity = { x: 0, y: 1 }; playSound('move'); }
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    if (velocity.x === 0) { velocity = { x: -1, y: 0 }; playSound('move'); }
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    if (velocity.x === 0) { velocity = { x: 1, y: 0 }; playSound('move'); }
                    break;
            }
        });

        // Touch Controls (Swipe)
        let touchStartX = 0;
        let touchStartY = 0;

        canvas.addEventListener('touchstart', function(e) {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
            e.preventDefault(); // Prevent scrolling
        }, {passive: false});

        canvas.addEventListener('touchend', function(e) {
            if (isGameOver || isPaused) return;

            let touchEndX = e.changedTouches[0].screenX;
            let touchEndY = e.changedTouches[0].screenY;
            
            handleSwipe(touchStartX, touchStartY, touchEndX, touchEndY);
            e.preventDefault();
        }, {passive: false});

        function handleSwipe(startX, startY, endX, endY) {
            let xDiff = endX - startX;
            let yDiff = endY - startY;

            if (Math.abs(xDiff) > Math.abs(yDiff)) {
                // Horizontal
                if (Math.abs(xDiff) > 30) { // Threshold
                    if (xDiff > 0 && velocity.x === 0) { velocity = { x: 1, y: 0 }; playSound('move'); }
                    else if (xDiff < 0 && velocity.x === 0) { velocity = { x: -1, y: 0 }; playSound('move'); }
                }
            } else {
                // Vertical
                if (Math.abs(yDiff) > 30) {
                    if (yDiff > 0 && velocity.y === 0) { velocity = { x: 0, y: 1 }; playSound('move'); }
                    else if (yDiff < 0 && velocity.y === 0) { velocity = { x: 0, y: -1 }; playSound('move'); }
                }
            }
        }

        function togglePause() {
            if (isGameOver || startScreen.classList.contains('hidden') === false) return;
            
            isPaused = !isPaused;
            if (isPaused) {
                pauseScreen.classList.remove('hidden');
            } else {
                pauseScreen.classList.add('hidden');
            }
        }

        // --- UI Button Listeners ---
        document.getElementById('startBtn').addEventListener('click', initGame);
        document.getElementById('restartBtn').addEventListener('click', initGame);
        document.getElementById('resumeBtn').addEventListener('click', togglePause);

    </script>
</body>
</html>
